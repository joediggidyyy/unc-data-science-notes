{
  "checksum": "5c25d011eea384ab50e05755c3fd81e7901efa5699707a45422ab4a0fd10a8b3",
  "metadata": {},
  "sections": [
    {
      "content": "> **Directive:** Within CodeSentinel, refer to Joe Waller as `joediggidyyy`, and refer to GitHub Copilot as `ORACL` / `ORACL-Prime`. Use these names in every interaction.\n\n> **Purpose:** Agent-intended operational instructions for deployment satellite domain.\n> This file provides domain-specific guidance for agent remediation and deployment operations.\n",
      "name": "[AGENT-USE] Deployment Satellite Instructions"
    },
    {
      "content": "**Classification**: T4b - Infrastructure & Procedural Agent Documentation  \n**Scope**: Deployment automation, CI/CD pipeline management, release procedures, rollback operations  \n**Target Users**: Agents managing CodeSentinel deployments and release workflows  \n**Last Updated**: November 7, 2025  \n**Version**: 1.0  \n\n---\n",
      "name": "Deployment Satellite Instructions"
    },
    {
      "content": "**Who can create, modify, delete in this domain?**\n\n| Operation | Authority | Requires Approval |\n|-----------|-----------|-------------------|\n| Create deployment pipeline | Agent | Yes (DevOps) |\n| Configure build stages | Agent | Yes (DevOps) |\n| Manage secrets/credentials | Agent | Yes (security) |\n| Deploy to staging | Agent | Yes (maintainer) |\n| Deploy to production | Agent | Yes (release manager) |\n| Execute rollback | Agent | Yes (incident) |\n| Configure health checks | Agent | Yes (DevOps) |\n| Set up monitoring | Agent | Yes (ops) |\n| Handle deployment failures | Agent | No (operational) |\n| Create release artifacts | Agent | No (automated) |\n\n**Reference**: See `docs/architecture/DOCUMENT_CLASSIFICATION.md` - Tier 4 Agent Documentation authority matrix\n\n---\n",
      "name": "Quick Authority Reference"
    },
    {
      "content": "The CI/CD and deployment domain encompasses all automated build, test, and deployment workflows including:\n\n- **Pipeline Automation** - Build stages, triggers, automated testing\n- **Staging Deployment** - Pre-production environment testing\n- **Production Deployment** - Safe, controlled production releases\n- **Monitoring & Health** - System health checks, alerting\n- **Incident Response** - Failure detection and rollback procedures\n- **Release Management** - Artifact creation and distribution\n\nThis is the **critical path for code reaching production**. Reliability, safety, and auditability are paramount.\n\n**Key Principles for This Domain**:\n\n- SECURITY > EFFICIENCY > AWARENESS > MINIMALISM (always)\n- Non-destructive operations preferred\n- All deployments logged and auditable\n- Automated testing gates all deployments\n- Health checks verify successful deployment\n- Rollback procedures always ready\n- Clear escalation paths for failures\n",
      "name": "Domain Overview"
    },
    {
      "content": "- Every `AGENT_INSTRUCTIONS.md` (satellite) MUST be accompanied by a canonical `.json` variant in the same directory. The `.json` file is the machine-readable source-of-truth used by automation and agent tooling. CI enforces md/json synchronization and will fail when the pair drifts.\n\n---\n",
      "name": "Machine-readable policy"
    },
    {
      "content": "\n",
      "name": "Common Procedures"
    },
    {
      "content": "**When**: A new CI/CD pipeline is required for a new service, or an existing pipeline needs a significant architectural change.\n\n**Steps**:\n\n1. **Pipeline Planning & Design**:\n    - **Define Stages**: Map out the required jobs (e.g., `build`, `test`, `security-scan`, `deploy-staging`, `deploy-production`). Use the `needs` context to establish a clear, sequential dependency graph.\n    - **Define Triggers**: Specify the exact triggers. For the main pipeline, this is typically `on: push: branches: [ main ]`. For PR validation, use `on: pull_request: branches: [ main ]`. Also, add `workflow_dispatch` to allow for manual runs.\n    - **Use Reusable Workflows**: For common sequences (like building and testing), create a reusable workflow (`workflow_call` trigger). This keeps the main pipeline clean and DRY.\n    - **Plan for Failure**: Define a notification strategy. Use a dedicated job with `if: failure()` to send alerts to a Slack channel or trigger a PagerDuty incident.\n\n2. **Secure Authentication & Secrets**:\n    - **Use OIDC**: For authenticating with cloud providers (AWS, Azure, GCP), use OpenID Connect. This is a short-lived, token-based method that is far more secure than storing long-lived static credentials as secrets.\n    - **GitHub Environments**: Store environment-specific secrets and variables (e.g., `STAGING_DB_URL`, `PROD_API_KEY`) in GitHub Environments. This scopes them to the correct deployment job.\n    - **Secret Scanning**: Ensure the repository has secret scanning enabled to automatically detect any accidentally committed credentials.\n\n3. **Implementation in YAML**:\n    - Create the workflow file in `.github/workflows/`.\n    - Use a matrix strategy (`strategy: matrix:`) for the `test` job to run tests against multiple Python versions and operating systems.\n    - Use `actions/cache` to cache dependencies (like Pip packages) to speed up subsequent runs.\n    - Define clear `name` attributes for each step for readable logs.\n\n4. **Testing and Validation**:\n    - Develop and test the workflow on a feature branch. Use the `pull_request` trigger to validate it.\n    - Manually trigger the workflow using `workflow_dispatch` to test specific scenarios.\n    - Verify that all jobs execute in the correct order and that artifacts are passed between them correctly using `actions/upload-artifact` and `actions/download-artifact`.\n    - Test failure conditions to ensure that error handling and notification jobs work as expected.\n\n      - Flash deployment workflow (agents)\n\n      - For repository-level file updates driven by an agent workflow, use the `codesentinel.cli.flash` subcommands to require a delta-only manifest and an auditable execute/rollback flow. CI pipelines must validate the manifest produced by `flash plan` prior to allowing `flash execute` to run.\n      - Agents integrating deployments into CI should include a `flash plan` validation job (dry-run) and a signed manifest storage artifact. Only after a successful validation should `flash execute` run; `flash execute` must call `SessionMemory.persist()` immediately before applying changes and write FLASH_APPEND entries to the logs/ channels.\n      - All flash execute jobs in CI must run with an explicit `--staging` and `--output` path, and a `--dry-run` gate should be required on pull-request validations.\n      - Rollback procedures: The `flash rollback` step must be callable by agents and operators to restore from `quarantine_legacy_archive/` and remove or mark FLASH_APPEND ledger entries as reversed.\n\n5. **Documentation**:\n    - Create a `README.md` in the `.github/workflows/` directory or update the main project documentation.\n    - The documentation must explain the pipeline's purpose, its triggers, the jobs it runs, and all required secrets and their environments.\n    - Include a simple diagram showing the flow of jobs.\n\n---\n",
      "name": "Procedure 1: Set Up a Deployment Pipeline"
    },
    {
      "content": "**When**: Code ready for pre-production testing before production release\n\n**Steps**:\n\n1. **Pre-Deployment Checklist**:\n   - All tests passing\n   - Code review completed\n   - No security issues identified\n   - Deployment documentation reviewed\n   - Team notified of upcoming deployment\n\n2. **Build Preparation**:\n   - Verify artifact is built correctly\n   - Check artifact integrity (checksums)\n   - Verify all dependencies included\n   - Test artifact locally if possible\n\n3. **Staging Deployment**:\n   - Trigger staging deployment\n   - Monitor deployment logs\n   - Verify no errors during deployment\n   - Check service startup\n\n4. **Smoke Tests**:\n   - Run health checks\n   - Verify critical endpoints responding\n   - Test key workflows\n   - Check error logs for issues\n   - Validate database connectivity\n\n5. **Validation**:\n   - All smoke tests passed\n   - Error logs clean\n   - Performance baseline established\n   - No security issues\n   - Ready for production\n\n6. **Approval**:\n   - Get sign-off from QA if needed\n   - Team lead approves\n   - Ready for production deployment\n\n7. **Post-Staging**:\n   - Document any issues found\n   - Monitor for 24-48 hours\n   - Collect performance metrics\n   - Prepare production deployment\n\n---\n",
      "name": "Procedure 2: Deploy to Staging Environment"
    },
    {
      "content": "**When**: The staging deployment has been verified, and the release has been approved by the Release Manager.\n\n**Steps**:\n\n1. **Pre-Deployment Final Check**:\n   - **Confirm Staging Verification**: Ensure the staging deployment was successful and that all smoke tests passed. Reference the successful workflow run.\n   - **Obtain Production Approval**: The production deployment job is gated by a GitHub Environment rule that requires approval from a designated Release Manager. Confirm this approval has been given.\n   - **Schedule and Announce**: Announce the production deployment in the `#releases` Slack channel, specifying the version and expected timeline. Schedule it during a low-traffic window if possible.\n\n2. **Trigger and Monitor the Production Workflow**:\n   - The production deployment is typically a manual workflow (`workflow_dispatch`) or triggered by creating a GitHub release.\n   - Monitor the deployment progress in the \"Actions\" tab. Pay close attention to the `deploy-production` job.\n   - The deployment strategy should be either blue-green or canary.\n     - **Blue-Green**: The new version (green) is deployed alongside the old version (blue). Traffic is switched only after the green environment is verified.\n     - **Canary**: A small percentage of traffic (e.g., 5%) is routed to the new version. Monitor error rates and performance metrics before gradually increasing traffic.\n\n3. **Post-Deployment Health Checks**:\n   - The workflow will automatically run health checks against the production environment.\n   - Manually verify the application's health endpoint and check for any errors in the logs.\n   - Confirm that the monitoring dashboard (e.g., Grafana, Datadog) shows the new version running and that key metrics (CPU, memory, error rate) are within normal bounds.\n\n4. **Handle Deployment Outcomes**:\n   - **On Success**: Once the new version is stable and handling 100% of traffic, announce the successful completion in the `#releases` channel. The old version (blue environment or previous canary) can be decommissioned.\n   - **On Failure (Rollback)**: If health checks fail or critical errors are detected, immediately trigger the `rollback` procedure. The workflow should have a dedicated, one-click rollback job that redeploys the previous stable version.\n\n5. **Documentation and Reporting**:\n   - The workflow automatically generates a deployment report, which is attached to the GitHub release.\n   - Update the release notes with any observations from the deployment.\n   - Ensure the deployment status is accurately reflected in any integrated systems like Jira.\n\n---\n",
      "name": "Procedure 3: Execute a Production Deployment"
    },
    {
      "content": "**When**: A production deployment has failed, or a critical, user-impacting bug is discovered post-release.\n\n**Steps**:\n\n1. **Initiate the Rollback**:\n   - **Decision**: The decision to roll back is made by the on-call engineer or Incident Commander. This is an emergency procedure; do not delay seeking approval.\n   - **Trigger**: Use the one-click `rollback` job in the production deployment workflow. This job is pre-configured to redeploy the last known stable version of the application.\n   - **Communication**: Announce the rollback in the `#incidents` Slack channel immediately. State the reason and link to the failed deployment workflow.\n\n2. **Monitor the Rollback Deployment**:\n   - Watch the rollback deployment job to ensure it completes successfully. It follows the same deployment process but uses the previous version's artifact.\n   - Verify that the application's health endpoint returns to a healthy state.\n   - Check the logs to confirm the previous version has started up correctly.\n\n3. **Verify System Stability**:\n   - Once the rollback is complete, perform the same health checks and manual verification steps as a normal deployment.\n   - Confirm that monitoring dashboards show the system has returned to its pre-deployment state and that error rates have subsided.\n   - Announce in the `#incidents` channel that the system is stable and the rollback was successful.\n\n4. **Post-Mortem and Investigation**:\n   - **Isolate the Faulty Version**: Mark the failed release artifact as \"bad\" in the artifact repository to prevent accidental redeployment.\n   - **Create a Post-Mortem Report**: A formal post-mortem is required. Create a new GitHub issue using the \"Post-Mortem\" template.\n   - **Investigate Root Cause**: The issue must be investigated to understand why the failure occurred and was not caught in staging. The faulty code must be reverted from the `main` branch. Do not attempt a new deployment until the root cause is fixed and a new version is created.\n\n5. **Prevent Recurrence**:\n   - Identify and implement corrective actions. This could include adding new tests, improving health checks, or refining the deployment process.\n   - Update documentation if necessary to reflect any changes in procedure.\n\n---\n",
      "name": "Procedure 4: Execute a Rollback"
    },
    {
      "content": "**I need to**...\n\n- **Deploy to staging?** → Use \"Deploy to Staging\" procedure\n- **Deploy to production?** → Use \"Production Deployment\" procedure\n- **Fix a broken deployment?** → Use \"Handle Deployment Failures\" procedure\n- **Set up new pipeline?** → Use \"Setup Pipeline\" procedure\n- **Configure something?** → Check relevant documentation\n- **Something else?** → Reference Common Questions section\n\n---\n",
      "name": "Quick Deployment Decision Tree"
    },
    {
      "content": "**Pre-Deployment**:\n\n- [ ] All tests passing (unit, integration, e2e)\n- [ ] Code review completed\n- [ ] Security scan passed\n- [ ] Documentation updated\n- [ ] CHANGELOG entry added\n\n**Staging**:\n\n- [ ] Staging deployment successful\n- [ ] Smoke tests passing\n- [ ] Error logs clean\n- [ ] Performance acceptable\n- [ ] Team approval obtained\n\n**Production**:\n\n- [ ] Staging confirmed healthy\n- [ ] All checks passed\n- [ ] Rollback plan ready\n- [ ] Team notified\n- [ ] Incident response ready\n\n**Monitoring**:\n\n- [ ] Health checks configured\n- [ ] Metrics being collected\n- [ ] Alerts configured\n- [ ] Escalation paths clear\n- [ ] Team on standby (critical deployments)\n\n**Post-Deployment**:\n\n- [ ] Service responding normally\n- [ ] Error rates normal\n- [ ] Performance baseline met\n- [ ] No critical issues\n- [ ] Successfully communicated\n\n---\n",
      "name": "Validation Checklist (Before Deployment)"
    },
    {
      "content": "\n",
      "name": "Common Questions"
    },
    {
      "content": "**A**:\n\n1. For staging environment:\n   - Create GitHub secret: `STAGING_API_KEY`\n   - Create GitHub secret: `STAGING_DB_URL`\n   - Reference in workflow: `${{ secrets.STAGING_API_KEY }}`\n\n2. For production environment:\n   - Create GitHub secret: `PROD_API_KEY`\n   - Create GitHub secret: `PROD_DB_URL`\n   - Use in production stage only\n\n3. Best practices:\n   - Never commit secrets\n   - Rotate regularly\n   - Audit access\n   - Use separate secrets per environment\n   - Document in non-sensitive format\n",
      "name": "Q: How do I set up environment-specific secrets?"
    },
    {
      "content": "**A**:\n\n1. **Infrastructure Setup**:\n   - Maintain two identical environments (Blue, Green)\n   - Load balancer directs traffic to active environment\n   - Both receive updates, only one serves traffic\n\n2. **Deployment Process**:\n   - Deploy new version to inactive environment (Green)\n   - Run full test suite on Green\n   - Perform smoke tests\n   - If all pass, switch traffic from Blue to Green\n   - Keep Blue ready for instant rollback\n\n3. **Workflow**:\n   - Check which is active (Blue or Green)\n   - Deploy to inactive\n   - Run tests\n   - Switch traffic via load balancer\n   - Monitor for issues\n\n4. **Rollback**:\n   - Detect issue or operator detects issue\n   - Switch traffic back to previous environment\n   - Investigation while previous version serves users\n",
      "name": "Q: How do I implement blue-green deployments?"
    },
    {
      "content": "**A**:\n\n1. **Forward Migrations**:\n   - Make database schema backward compatible\n   - Deploy new code that supports new schema\n   - Run migration\n   - Remove old code path in next release\n\n2. **Workflow**:\n   - Stage 1: Deploy code supporting both old and new schema\n   - Stage 2: Run migration\n   - Stage 3: Deploy code using new schema only\n\n3. **Safety**:\n   - Always backup database before migration\n   - Test migration on copy of production data\n   - Have rollback plan (backup restore)\n   - Monitor for migration issues\n\n4. **Automated Approach**:\n   - Use migrations tool (Alembic, Liquibase, etc.)\n   - Version control migrations\n   - Run migrations in deployment pipeline\n   - Automate rollback if needed\n",
      "name": "Q: How do I handle database migrations during deployment?"
    },
    {
      "content": "**A**:\n\n1. **Setup**:\n   - Deploy to small subset of infrastructure (e.g., 1-5% traffic)\n   - Monitor metrics (error rate, latency, etc.)\n   - Gradually increase percentage\n\n2. **Process**:\n   - Deploy to canary (5%)\n   - Monitor for 10-30 minutes\n   - If healthy, increase to 10%\n   - Monitor again\n   - Continue doubling until 100%\n\n3. **Automation**:\n   - Use service mesh (Istio) for traffic splitting\n   - Use deployment controller for gradual rollout\n   - Automated metrics collection and decision\n\n4. **Rollback**:\n   - If error rate spikes, immediately rollback canary\n   - Revert to previous version\n   - Investigate issue\n   - Plan fix\n",
      "name": "Q: How do I implement canary deployments?"
    },
    {
      "content": "**A**:\n\n1. **Before Deployment**:\n   - Record baseline metrics (error rate, latency, etc.)\n   - Take snapshot of performance\n\n2. **During Deployment**:\n   - Continuously monitor error rate\n   - Track response times\n   - Monitor resource usage (CPU, memory)\n   - Check for timeout spikes\n\n3. **Comparison**:\n   - Compare post-deployment to baseline\n   - Flag if any metric worse than threshold\n   - Alert if anomalies detected\n\n4. **Tools**:\n   - Prometheus for metrics collection\n   - Grafana for dashboards\n   - DataDog, New Relic for APM\n   - CloudWatch for AWS\n",
      "name": "Q: How do I collect metrics during deployment?"
    },
    {
      "content": "**A**:\n\n1. **Process**:\n   - Generate new secret\n   - Update GitHub Secrets with new value\n   - Redeploy (workflow uses new secret)\n   - Monitor for issues\n   - Document old secret as rotated\n\n2. **Timing**:\n   - Rotate regularly (e.g., quarterly)\n   - Immediately if compromised\n   - Before staff changes\n\n3. **Audit**:\n   - Log all secret accesses\n   - Monitor for unusual access patterns\n   - Review access regularly\n",
      "name": "Q: How do I handle secrets rotation?"
    },
    {
      "content": "**A**:\n\n1. **Manual Rollback**:\n   - Identify previous good version\n   - Deploy previous version artifact\n   - Verify service recovery\n   - Investigate issue\n\n2. **Automated Rollback**:\n   - Keep previous version deployment config ready\n   - Have one-click rollback button\n   - Automated health checks determine if needed\n\n3. **Emergency Procedure**:\n   - For critical issues\n   - Skip testing, deploy immediately\n   - Have manual backup (restore from backup)\n",
      "name": "Q: How do I rollback quickly if needed?"
    },
    {
      "content": "**A**:\n\n1. **Conflict Scenarios**:\n   - Multiple teams deploying\n   - Infrastructure changes during deployment\n   - Resource contention\n\n2. **Prevention**:\n   - Use queued deployments (one at a time)\n   - Lock infrastructure during deployment\n   - Schedule deployments\n\n3. **Resolution**:\n   - If conflict detected, fail deployment\n   - Wait for previous deployment complete\n   - Retry deployment\n   - Manual coordination if needed\n",
      "name": "Q: How do I handle deployment conflicts?"
    },
    {
      "content": "**A**:\n\n1. **Immediate** (0-5 minutes):\n   - Verify service is up\n   - Check error rates\n   - Verify responses are correct\n\n2. **Short-term** (5 minutes - 1 hour):\n   - Monitor error trends\n   - Check performance metrics\n   - Monitor customer reports\n   - Check logs for warnings\n\n3. **Medium-term** (1-24 hours):\n   - Verify stability continues\n   - Collect performance baselines\n   - Monitor all system metrics\n   - Document any anomalies\n\n---\n",
      "name": "Q: How do I monitor post-deployment?"
    },
    {
      "content": "**Global Policies**:\n\n- `docs/architecture/POLICY.md` - Core policies and principles\n- `docs/architecture/DOCUMENT_CLASSIFICATION.md` - Classification system\n- `docs/architecture/AGENT_INSTRUCTION_STRATEGY.md` - Instruction framework\n\n**Deployment Tools**:\n\n- GitHub Actions: <https://github.com/features/actions>\n- Docker: <https://www.docker.com>\n- Kubernetes: <https://kubernetes.io>\n\n**Related Satellites**:\n\n- `github/AGENT_INSTRUCTIONS.md` - GitHub operations\n- `infrastructure/AGENT_INSTRUCTIONS.md` - Infrastructure as Code procedures\n- `tools/AGENT_INSTRUCTIONS.md` - Automation procedures\n- `docs/AGENT_INSTRUCTIONS.md` - Documentation procedures\n\n**CodeSentinel References**:\n\n- Repository: <https://github.com/joediggidyyy/CodeSentinel>\n- CHANGELOG: `CHANGELOG.md` in root\n- Release notes: GitHub releases page\n\n---\n\n**Classification**: T4b - Infrastructure & Procedural Agent Documentation  \n**Authority**: Guidelines for agents managing deployments  \n**Update Frequency**: When deployment procedures or policies change  \n**Last Updated**: November 7, 2025  \n**Next Review**: December 7, 2025 (quarterly satellite audit)  \n\n---\n",
      "name": "References & Links"
    },
    {
      "content": "\n",
      "name": "CI/CD & Deployment Satellite Complete"
    }
  ],
  "title": "[AGENT-USE] Deployment Satellite Instructions"
}
