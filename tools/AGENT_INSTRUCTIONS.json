{
  "checksum": "bac2d102ac1aa5d8c30764945a3f5e72fa08ebefccfb707aafd7a3b6ee029580",
  "metadata": {},
  "sections": [
    {
      "content": "> **Directive:** Within CodeSentinel, refer to Joe Waller as `joediggidyyy`, and refer to GitHub Copilot as `ORACL` / `ORACL-Prime`. Use these names in every interaction.\n\n> **Purpose:** Agent-intended operational instructions for tools satellite domain.\n> This file provides domain-specific guidance for agent remediation and maintenance operations.\n",
      "name": "[AGENT-USE] Tools Satellite Instructions"
    },
    {
      "content": "**Classification**: T4b - Infrastructure & Procedural Agent Documentation  \n**Scope**: Maintenance automation, scheduler tasks, background jobs in tools/ directory  \n**Target Users**: Agents implementing automated maintenance workflows  \n**Last Updated**: November 7, 2025  \n**Version**: 1.0\n\n---\n",
      "name": "Tools Satellite Instructions"
    },
    {
      "content": "**Who can create, modify, delete automation tasks?**\n\n| Operation | Authority | Requires Approval |\n|-----------|-----------|-------------------|\n| Create scheduler task | Agent | Yes (user verification) |\n| Create maintenance job | Agent | Yes (user verification) |\n| Modify task timing | Agent | Yes (user verification) |\n| Modify task logic | Agent | No (bug fixes), Yes (major changes) |\n| Delete task | Agent | Yes (explicit user instruction) |\n| Add task dependency | Agent | Yes (user verification) |\n| Change task priority | Agent | Yes (user verification) |\n| Add alerting to task | Agent | No |\n| Modify alert thresholds | Agent | Yes (impacts operations) |\n| Schedule new job type | Agent | Yes (user verification) |\n\n**Reference**: See `docs/architecture/DOCUMENT_CLASSIFICATION.md` - Authority matrices for infrastructure code\n\n---\n",
      "name": "Quick Authority Reference"
    },
    {
      "content": "The `tools/` directory contains CodeSentinel automation infrastructure including:\n\n- **Scheduler** (`scheduler.py`) - Task scheduling and execution\n- **Maintenance Jobs** - Daily, weekly, monthly tasks\n- **Background Processes** - Long-running automation\n- **Configuration** (`tools/config/`) - Automation settings and policies\n- **Monitoring** - Task execution tracking and alerting\n\n**Core Scheduler Tasks** (Always Running):\n\n1. **Daily Maintenance** - Configuration validation, cleanup\n2. **Security Scan** - Dependency vulnerability checking (weekly)\n3. **Dependency Update** - Check for updates and patches (weekly)\n4. **Backup** - Archive backup operations (daily)\n5. **Config Validation** - Policy compliance checking (daily)\n6. **Metadata Update** - Archive metadata refresh (daily)\n",
      "name": "Domain Overview"
    },
    {
      "content": "- All satellite `AGENT_INSTRUCTIONS.md` files in this repository must maintain a corresponding machine-readable `.json` pair. The JSON file is the canonical representation for agents and automation. CI will enforce md/json sync: any divergence will cause a failure until both files match.\n",
      "name": "Machine-readable policy"
    },
    {
      "content": "- Add scheduled jobs that periodically run `codesentinel.cli.flash plan --staging <staging_dir> --output <path>` in dry-run mode to validate that staging trees can be cleanly flashed into the live tree without touching whitelisted artifacts. These jobs should:\n  - Run nightly in staging and fail the job when the manifest would touch protected namespaces (QuestFrames, QuestStack ledgers, session exports, vault assets, etc.).\n  - Emit a summary to the `logs/` channels and create an artifact containing the signed manifest for auditability.\n- Add a weekly ledger-scan job to validate that FLASH_APPEND.log files are consistent (no gaps, signatures valid) and report anomalies to ops channels.\n- When designing these tasks, follow the task registration and testing flows in this document to ensure non-disruptive, well-logged execution and clear alerting.\n\n**Key Principles for This Domain**:\n\n- Non-disruptive (background execution)\n- Comprehensive logging (all actions logged)\n- Error handling (failures logged and reported)\n- Scheduling precision (timers accurate)\n- Task isolation (independent execution)\n- Alerting integration (failures alert users)\n- Policy compliance (verify SECURITY > EFFICIENCY > AWARENESS > MINIMALISM)\n\n---\n",
      "name": "Flash CLI integration (scheduled checks)"
    },
    {
      "content": "\n",
      "name": "Common Procedures"
    },
    {
      "content": "**When**: New automated operation needed (daily, weekly, or monthly)\n\n**Steps**:\n\n1. **Verify Authority**: Get user approval for new task\n\n2. **Define Task Requirements**:\n   - What should the task do?\n   - How often should it run? (daily, weekly, monthly)\n   - What time(s) should it run?\n   - What's the timeout (max execution time)?\n   - What resources will it use?\n   - What can fail safely?\n\n3. **Design Task Implementation**:\n   - Create function: `def task_[name](config_manager, alert_manager):`\n   - Parameters: Config manager, alert manager (standard)\n   - Return: Execution result (success/failure with details)\n   - Error handling: All exceptions caught and logged\n   - Logging: Important events logged with timestamps\n\n4. **Implement Task Function**:\n\n   ```python\n   def task_my_maintenance(config_manager, alert_manager):\n       \"\"\"\n       Perform my maintenance operation.\n       \n       Runs: Daily at 2 AM\n       Timeout: 5 minutes\n       \"\"\"\n       logger = logging.getLogger(__name__)\n       try:\n           logger.info(\"Starting my maintenance task\")\n           # Perform work here\n           result = perform_operation()\n           logger.info(f\"Completed successfully: {result}\")\n           return {\"status\": \"success\", \"details\": result}\n       except Exception as e:\n           logger.error(f\"Task failed: {e}\")\n           alert_manager.send_alert(\"Task Failed\", f\"my_maintenance: {e}\")\n           return {\"status\": \"failed\", \"error\": str(e)}\n   ```\n\n5. **Register Task with Scheduler**:\n   - Add to tasks registry in scheduler\n   - Define schedule: `schedule.every().day.at(\"02:00\").do(task_my_maintenance)`\n   - Set timeout: `timeout = 300  # 5 minutes`\n   - Document in scheduler configuration\n\n6. **Add Configuration**:\n   - Add to `tools/config/scheduling.json`\n   - Document schedule, timeout, dependencies\n   - Document success criteria\n   - Document failure conditions\n\n7. **Add Monitoring**:\n   - Add to metrics tracking\n   - Define success condition\n   - Define alert conditions\n   - Configure alert recipients\n\n8. **Testing**:\n   - Test in isolation (without scheduler)\n   - Test with actual data/conditions\n   - Test error conditions\n   - Verify logging output\n   - Test alert generation\n   - Verify task timeout works\n\n9. **Deployment**:\n   - Add to scheduler on startup\n   - Monitor first few executions\n   - Verify timing accurate\n   - Verify logging complete\n   - Adjust if needed\n\n10. **Validation**:\n    - Task executes on schedule\n    - Logging shows all actions\n    - Alerts trigger appropriately\n    - No resource leaks\n    - Complies with policies\n\n11. **Commit**:\n    - Message: `feat(scheduler): add [task name] task`\n    - Include task implementation\n    - Include configuration\n    - Include tests\n\n---\n",
      "name": "Procedure 1: Add New Scheduler Task"
    },
    {
      "content": "**When**: Task needs to run more/less often or timeout is incorrect\n\n**Steps**:\n\n1. **Verify Authority**: Get user verification for timing changes\n\n2. **Analyze Current Performance**:\n   - How long does task typically take?\n   - What's the current schedule?\n   - How often is it timing out?\n   - What's the resource usage pattern?\n\n3. **Plan Changes**:\n   - New schedule: Define exact time or interval\n   - New timeout: Calculate based on performance\n   - Document rationale for changes\n   - Identify impact on other tasks\n\n4. **Update Scheduler Config**:\n   - Modify `tools/config/scheduling.json`\n   - Update schedule definition\n   - Update timeout value\n   - Document previous values\n\n5. **Update Task Implementation** (if needed):\n   - Adjust task to meet new timeout\n   - Optimize if necessary\n   - Maintain functionality\n   - No shortcuts that reduce quality\n\n6. **Testing**:\n   - Run task manually with new timeout\n   - Verify completes within timeout\n   - Monitor several executions with new schedule\n   - Verify no conflicts with other tasks\n   - Check resource usage\n\n7. **Gradual Rollout**:\n   - Test in non-production if possible\n   - Monitor first week of changes\n   - Watch for issues or conflicts\n   - Adjust if necessary\n   - Finalize configuration\n\n8. **Documentation**:\n   - Update schedule documentation\n   - Note why change was made\n   - Document new timing\n   - Add to CHANGELOG\n\n9. **Validation**:\n    - Task runs on new schedule\n    - Completes within timeout\n    - No conflicts with other tasks\n    - Logging accurate\n    - Alerts still working\n\n10. **Commit**:\n    - Message: `ops(scheduler): adjust [task] schedule/timeout`\n    - Document old and new values\n    - Note rationale\n\n---\n",
      "name": "Procedure 2: Modify Task Schedule or Timeout"
    },
    {
      "content": "**When**: Task fails or doesn't produce expected results\n\n**Steps**:\n\n1. **Locate Task Logs**:\n   - Check scheduler logs\n   - Find task execution entries\n   - Collect error messages\n   - Note timing of failures\n   - Identify pattern (always, sometimes, when?)\n\n2. **Understand Failure**:\n   - What was the task trying to do?\n   - What went wrong?\n   - Is it a logic error or environment issue?\n   - Did task timeout?\n   - Are dependencies missing?\n\n3. **Reproduce Issue**:\n   - Run task manually (if safe)\n   - Use same inputs as scheduled run\n   - Verify error reproduces\n   - Document reproduction steps\n\n4. **Diagnose Root Cause**:\n   - Check logs for stack traces\n   - Check dependencies (files, services, permissions)\n   - Check configuration (values correct?)\n   - Check resource availability (disk, memory)\n   - Check for external factor impact\n\n5. **Implement Fix**:\n   - Fix identified issue\n   - Update error handling if needed\n   - Improve logging for visibility\n   - Consider edge cases\n   - Don't remove features\n\n6. **Test Fix**:\n   - Run task manually with fix\n   - Verify it completes successfully\n   - Run full test suite\n   - Monitor several scheduled runs\n   - Watch for side effects\n\n7. **Alerting Adjustment** (if needed):\n   - Update alert conditions if appropriate\n   - Adjust thresholds if too sensitive\n   - Ensure alerts still trigger on real failures\n   - Document alert logic\n\n8. **Validation**:\n    - Task completes successfully\n    - Logging shows correct output\n    - No error alerts\n    - Dependencies available\n    - No timeout issues\n\n9. **Commit**:\n    - Message: `fix(scheduler): resolve [task] failure`\n    - Document root cause\n    - Note fix applied\n    - Reference logs if helpful\n\n---\n",
      "name": "Procedure 3: Debug Failed Scheduler Task"
    },
    {
      "content": "**When**: Task requires other operations to complete first\n\n**Steps**:\n\n1. **Verify Authority**: Get user verification for dependency changes\n\n2. **Identify Dependencies**:\n   - What must run before this task?\n   - What's the execution order?\n   - How is failure in dependency handled?\n   - Are there circular dependencies?\n\n3. **Design Dependency Handling**:\n   - Hard dependency: Wait for completion\n   - Soft dependency: Proceed but log warning\n   - Conditional: Only run if dependency succeeded\n   - Timeout: How long to wait for dependency?\n\n4. **Implement Dependency Check**:\n   - Add logic to check prerequisite status\n   - Verify prerequisite completed successfully\n   - Handle timeout scenarios\n   - Log dependency status\n   - Return appropriate status\n\n5. **Update Scheduler Config**:\n   - Document dependencies in config\n   - Define execution order\n   - Set timeout for dependency wait\n   - Define failure handling\n\n6. **Testing**:\n   - Test with dependency succeeded\n   - Test with dependency failed\n   - Test with dependency timeout\n   - Test execution order\n   - Monitor integrated execution\n\n7. **Documentation**:\n   - Document dependency relationship\n   - Explain why dependency exists\n   - Document how failures handled\n   - Add to task documentation\n\n8. **Validation**:\n    - Dependency respected\n    - Correct execution order\n    - Failure handling correct\n    - Logging shows dependencies\n    - No deadlocks\n\n9. **Commit**:\n    - Message: `ops(scheduler): add dependency for [task]`\n    - Document dependency relationship\n\n---\n",
      "name": "Procedure 4: Add Task Dependencies or Prerequisites"
    },
    {
      "content": "**What are you doing?**\n\n- Adding new task? → Use \"Add New Scheduler Task\" procedure\n- Changing task schedule? → Use \"Modify Schedule/Timeout\" procedure\n- Task failed? → Use \"Debug Failed Task\" procedure\n- Adding dependencies? → Use \"Add Dependencies\" procedure\n- Monitoring task? → Check logs and metrics\n\n**What type of task?**\n\n- One-time operation? → Don't use scheduler (run manually)\n- Daily operation? → Use `schedule.every().day.at(\"HH:MM\")`\n- Weekly operation? → Use `schedule.every().monday.at(\"HH:MM\")`\n- Monthly operation? → Use date-based scheduling\n- Continuous polling? → Use background thread (not scheduler)\n\n**What's the scope?**\n\n- CodeSentinel-internal? → Implement in scheduler\n- System-level? → May need cron/systemd\n- External service? → May need API integration\n- User-triggered? → Create CLI command instead\n\n---\n",
      "name": "Quick Scheduler Decision Tree"
    },
    {
      "content": "**Standard Task Configuration** (`tools/config/scheduling.json`):\n\n```json\n{\n  \"tasks\": [\n    {\n      \"name\": \"daily_maintenance\",\n      \"type\": \"scheduled\",\n      \"schedule\": \"every().day.at('02:00')\",\n      \"timeout\": 300,\n      \"enabled\": true,\n      \"logging\": \"info\",\n      \"alerts_on_failure\": true,\n      \"alert_recipients\": [\"admin@example.com\"],\n      \"description\": \"Daily maintenance and cleanup operations\"\n    }\n  ]\n}\n```\n\n---\n",
      "name": "Task Configuration Reference"
    },
    {
      "content": "**Task Design**:\n\n- [ ] Task purpose clearly defined\n- [ ] Schedule requirements understood\n- [ ] Resource requirements estimated\n- [ ] Timeout calculated appropriately\n- [ ] Success criteria defined\n\n**Implementation**:\n\n- [ ] Task function created with proper signature\n- [ ] Error handling comprehensive\n- [ ] Logging includes important events\n- [ ] Config parameters used (not hardcoded)\n- [ ] No credentials in code\n\n**Testing**:\n\n- [ ] Task runs standalone successfully\n- [ ] Task completes within timeout\n- [ ] Error handling tested\n- [ ] Logging verified\n- [ ] No resource leaks\n\n**Integration**:\n\n- [ ] Task registered with scheduler\n- [ ] Configuration added\n- [ ] Dependencies resolved\n- [ ] No conflicts with other tasks\n- [ ] Alert logic configured\n\n**Compliance**:\n\n- [ ] Policy compliance verified\n- [ ] Non-disruptive execution\n- [ ] Proper error reporting\n- [ ] Audit trail maintained\n- [ ] Documentation complete\n\n---\n",
      "name": "Validation Checklist (Before Adding Task)"
    },
    {
      "content": "\n",
      "name": "Common Scheduler Questions"
    },
    {
      "content": "**A**: Two approaches:\n\n1. Create CLI command that calls task function directly\n2. Manual trigger: Stop scheduler, run task, restart scheduler\n3. Better: Create command-line option to run any task\n",
      "name": "Q: How do I run a task on demand instead of scheduled?"
    },
    {
      "content": "**A**: Debugging steps:\n\n1. Check logs for actual error\n2. Run task manually to reproduce\n3. Verify dependencies are available\n4. Check configuration values\n5. Verify permissions and access\n6. Adjust timeout if too aggressive\n7. Report if unresolvable\n",
      "name": "Q: What if a task fails consistently?"
    },
    {
      "content": "**A**: By default:\n\n- Python scheduler is single-threaded\n- Tasks run sequentially\n- Each waits for previous to complete\n- If you need parallel: Use threading/multiprocessing (advanced)\n",
      "name": "Q: Can multiple tasks run simultaneously?"
    },
    {
      "content": "**A**: Built-in safeguards:\n\n1. Task timeout (default: task max time)\n2. Process limits (OS-enforced)\n3. Manual intervention: Stop scheduler, investigate\n4. Monitor for long-running tasks\n",
      "name": "Q: How do I stop a runaway task?"
    },
    {
      "content": "**A**: Log these events:\n\n1. Task start: \"Starting [task name]\"\n2. Important milestones: \"Completed phase X\" — use deterministic phase tokens where appropriate, for example: \"Completed PHASE2b\" or \"Completed PHASE3_M1\". For artifact-related messages include timestamps: \"Completed PHASE3_M1_HEALTH_REPORT_20251127\".\n3. Errors: Complete error with context\n4. Task end: \"Completed successfully\" or \"Failed\"\n5. Summary: Key metrics/results\n\n---\n",
      "name": "Q: What should I log in a task?"
    },
    {
      "content": "**Core Documentation**:\n\n- Global Policy: `docs/architecture/POLICY.md`\n- Classification Framework: `docs/architecture/DOCUMENT_CLASSIFICATION.md`\n- General Strategy: `docs/architecture/AGENT_INSTRUCTION_STRATEGY.md`\n\n**Configuration Files**:\n\n- Scheduling Config: `tools/config/scheduling.json`\n- Alerts Config: `tools/config/alerts.json`\n- Policies Config: `tools/config/policies.json`\n\n**Scheduler Implementation**:\n\n- Scheduler: `codesentinel/utils/scheduler.py`\n- Config Manager: `codesentinel/utils/config.py`\n- Alert Manager: `codesentinel/utils/alerts.py`\n\n**Related Tasks**:\n\n- Daily Maintenance: `codesentinel/utils/scheduler.py` - `_run_daily_tasks()`\n- Weekly Tasks: `codesentinel/utils/scheduler.py` - `_run_weekly_tasks()`\n- Monthly Tasks: `codesentinel/utils/scheduler.py` - `_run_monthly_tasks()`\n\n---\n\n**Classification**: T4b - Infrastructure & Procedural Agent Documentation  \n**Authority**: Guidelines for agents managing automated maintenance  \n**Update Frequency**: When scheduler procedures or policies change  \n**Last Updated**: November 7, 2025  \n**Next Review**: December 7, 2025 (quarterly satellite audit)\n",
      "name": "References & Links"
    }
  ],
  "title": "[AGENT-USE] Tools Satellite Instructions"
}
